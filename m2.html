<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Маятники на Canvas</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: lightgrey; /* Добавление светло-серого фона */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="pendulumCanvas"></canvas>

<script>
    const canvas = document.getElementById('pendulumCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 3;
    const pendulumLength = 250; // Длина нитей маятников
    const ballRadius = 30; // Радиус шариков
    const ballDistance = ballRadius * 3; // Расстояние между маятниками (полтора диаметра)
    const colors = ['red', 'blue', 'green', 'yellow', 'orange', 'purple', 'cyan']; // Цвета маятников
    const g = 0.98; // Ускорение свободного падения

    // Параметры каждого маятника
    const pendulums = [
        { angle: -Math.PI / 4, angularVelocity: 0, color: colors[0] }, // Левый маятник отклонён
        { angle: 0, angularVelocity: 0, color: colors[1] },
        { angle: 0, angularVelocity: 0, color: colors[2] },
        { angle: 0, angularVelocity: 0, color: colors[3] },
        { angle: 0, angularVelocity: 0, color: colors[4] },
        { angle: 0, angularVelocity: 0, color: colors[5] },
        { angle: 0, angularVelocity: 0, color: colors[6] }
    ];

    // Добавляем звук
    const collisionSound = new Audio('https://www.soundjay.com/button/beep-07.wav');

    function drawPendulum(x, y, angle, color) {
        const ballX = x + pendulumLength * Math.sin(angle);
        const ballY = y + pendulumLength * Math.cos(angle);

        // Рисуем нить
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(ballX, ballY);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Рисуем шарик
        ctx.beginPath();
        ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        return { ballX, ballY };
    }

    function resolveCollision(p1, p2) {
        // Упругое столкновение по принципу обмена скоростями
        const tempVelocity = p1.angularVelocity;
        p1.angularVelocity = p2.angularVelocity;
        p2.angularVelocity = tempVelocity;

        // Проигрываем звук столкновения
        collisionSound.play();
    }

    function updatePhysics() {
        // Обновление углов движения маятников
        pendulums.forEach((pendulum) => {
            pendulum.angularVelocity += (-g / pendulumLength) * Math.sin(pendulum.angle);
            pendulum.angle += pendulum.angularVelocity;
        });

        // Проверка столкновений между шарами
        for (let i = 0; i < pendulums.length - 1; i++) {
            const p1 = pendulums[i];
            const p2 = pendulums[i + 1];

            // Вычисляем позиции шариков
            const x1 = centerX - (pendulums.length / 2 - i) * ballDistance + pendulumLength * Math.sin(p1.angle);
            const y1 = centerY + pendulumLength * Math.cos(p1.angle);

            const x2 = centerX - (pendulums.length / 2 - (i + 1)) * ballDistance + pendulumLength * Math.sin(p2.angle);
            const y2 = centerY + pendulumLength * Math.cos(p2.angle);

            const dist = Math.hypot(x2 - x1, y2 - y1);

            // Если произошло столкновение, обрабатываем его
            if (dist < 2 * ballRadius) {
                resolveCollision(p1, p2);

                // Раздвигаем маятники, чтобы избежать перекрытий
                const overlap = 2 * ballRadius - dist;
                const correctionX = (x2 - x1) / dist * overlap;
                const correctionY = (y2 - y1) / dist * overlap;

                p1.angle -= correctionX / pendulumLength;
                p2.angle += correctionX / pendulumLength;
            }
        }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        pendulums.forEach((pendulum, index) => {
            const x = centerX - (pendulums.length / 2 - index) * ballDistance;
            drawPendulum(x, centerY, pendulum.angle, pendulum.color);
        });
    }

    function animate() {
        updatePhysics();
        render();
        requestAnimationFrame(animate);
    }

    animate();
</script>
</body>
</html>
